<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
<head>
<!-- 2022-08-23 Tue 18:44 -->
<!-- <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"> -->
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Blog</title>
  <meta name="author" content="enxz" />
  <meta name="description" content="Keep It Simple, Stupid" />
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="tailwind.css" />

  <script LANGUAGE = "JavaScript">
    var xmlhttp;
    if (window.ActiveXObject) {//IE6, IE5 浏览器执行代码
        xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
    } else if (window.XMLHttpRequest) {//IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码
        xmlhttp = new XMLHttpRequest(); 									
    }
    xmlhttp.open("GET","http://121.36.227.227/ping?token=87221652a79fc3c9b04cde0b335fdd5b",true);
    xmlhttp.send(); //发送请求
    xmlhttp.onreadystatechange = doResult;								//回调函数，监听response消息事件

    function doResult() {
        if (xmlhttp.readyState == 4) {//4代表执行完成
            if (xmlhttp.status == 200) {//200代表执行成功
                var jsonValue = JSON.parse(xmlhttp.responseText);		//将responseText消息内容转换为js对象
                var code = jsonValue.code;//获取消息中code字段对应的值
                document.getElementById("uuid") = code
            }
        }
    }
    window.onload = doResult();
  </script>
</head>
<body>
  <div class="container mx-auto m-12">
    <h1 class="text-3xl font-bold underline text-yellow-200">
        Hello world!
        <p id="uuid">hjkl789-678903j-bnm-jkl-123432</p>
    </h1>
    <div class="container mx-auto px-4">
        <iframe class="w-full aspect-video" src="https://media.w3.org/2010/05/sintel/trailer.mp4"></iframe>
        <div class="prose">
            <p class="break-words">git branch 列出本地已经存在的分支，并且当前分支会用*标记</p>
            <p class="break-words">git branch -r 查看远程版本库的分支列表</p>
            <p class="break-words">git branch -a 查看所有分支列表（包括本地和远程，remotes/开头的表示远程分支）</p>
            <p class="break-words">git branch -v 查看一个分支的最后一次提交</p>
            <p class="break-words">git branch --merged  查看哪些分支已经合并到当前分支</p>
            <p class="break-words">git branch --no-merged 查看所有未合并工作的分支</p>
        </div>
    </div>
    <div>
      <p>通过共享内存来通讯和通过通讯来共享内存是并发编程中的两种编程风格。当通过共享内存来通讯的时候，我们需要一些传统的并发同步技术（比如互斥锁）来避免数据竞争。</p>

      <p>Go提供了一种独特的并发同步技术来实现通过通讯来共享内存。此技术即为通道。 我们可以把一个通道看作是在一个程序内部的一个先进先出（FIFO：first in first out）数据队列。 一些协程可以向此通道发送数据，另外一些协程可以从此通道接收数据。</p>

      <p>随着一个数据值的传递（发送和接收），一些数据值的所有权从一个协程转移到了另一个协程。 当一个协程发送一个值到一个通道，我们可以认为此协程释放了（通过此发送值可以访问到的）一些值的所有权。 当一个协程从一个通道接收到一个值，我们可以认为此协程获取了（通过此接受值可以访问到的）一些值的所有权。</p>

      <p>当然，在通过通道传递数据的时候，也可能没有任何所有权发生转移。</p>

      <p>所有权发生转移的值常常被传递的值所引用着，但有时候也并非如此。 在Go中，数据所有权的转移并非体现在语法上，而是体现在逻辑上。 Go通道可以帮助程序员轻松地避免数据竞争，但不会防止程序员因为犯错而写出错误的并发代码的情况发生。</p>
      
      <p>传统的数据同步技术提供在sync和sync/atomic标准库包中。</p>
    </div>
    
    <article class="prose lg:prose-xl">
      <h1>通道类型和值</h1>
      <p>通道可以是双向的，也可以是单向的。</p>
      <ul>
        <li>字面形式chan T表示一个元素类型为T的双向通道类型。 编译器允许从此类型的值中接收和向此类型的值中发送数据。</li>
        <li>字面形式chan<- T表示一个元素类型为T的单向发送通道类型。 编译器不允许从此类型的值中接收数据。</li>
        <li>字面形式<-chan T表示一个元素类型为T的单向接收通道类型。 编译器不允许向此类型的值中发送数据。</li>
      </ul>
    </article>

  </div>
</body>
</html>