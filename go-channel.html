<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
<head>
<!-- 2022-08-23 Tue 18:44 -->
<!-- <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"> -->
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Blog</title>
  <meta name="author" content="enxz" />
  <meta name="description" content="Keep It Simple, Stupid" />
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="tailwind.css" />
  <script LANGUAGE = "JavaScript" src="jquery-3.6.1.min.js"></script>
  <script LANGUAGE = "JavaScript">
    var xmlhttp;
    if (window.ActiveXObject) {//IE6, IE5 浏览器执行代码
        xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
    } else if (window.XMLHttpRequest) {//IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码
        xmlhttp = new XMLHttpRequest(); 									
    }
    xmlhttp.open("GET","http://121.36.227.227/ping?token=87221652a79fc3c9b04cde0b335fdd5b",true);
    xmlhttp.send(); //发送请求
    xmlhttp.onreadystatechange = doResult;								//回调函数，监听response消息事件

    function doResult() {
        if (xmlhttp.readyState == 4) {//4代表执行完成
            if (xmlhttp.status == 200) {//200代表执行成功
                var jsonValue = JSON.parse(xmlhttp.responseText);		//将responseText消息内容转换为js对象
                var data = jsonValue.data;//获取消息中code字段对应的值
                $("#forever").text("`" + data + "`")
            }
        }
    }
    window.onload = doResult();
  </script>
</head>
<body>
  <div class="container px-12">
    <div class="text-purple-300 text-center px-12 py-12 inline-block font-sans font-mono font-serif text-3xl italic font-medium tracking-wider underline decoration-purple-300">
      Enxz's Document 
      <p id="forever" class="text-sm border-2 rounded border-red-200 my-4"></p>
    </div>
    <iframe class="w-full aspect-video" src="https://media.w3.org/2010/05/sintel/trailer.mp4"></iframe>
    
    <div class="grid grid-flow-col auto-cols-max py-12 justify-center">

      <div class="border-2 border-blue-400 rounded shadow-2xl ">
          <div class="text-center text-purple-500">Go</div>
          <article class="prose px-4 py-4 text-sm font-mono font-serif text-left">
            <h4>通道</h4>
            <p>通道是Go中的一种一等公民类型。</p>
      
            <h4>通道（channel）介绍</h4>
            <p>通过共享内存来通讯和通过通讯来共享内存是并发编程中的两种编程风格。当通过共享内存来通讯的时候，我们需要一些传统的并发同步技术（比如互斥锁）来避免数据竞争。</p>
      
            <p>Go提供了一种独特的并发同步技术来实现通过通讯来共享内存。此技术即为通道。 我们可以把一个通道看作是在一个程序内部的一个先进先出（FIFO：first in first out）数据队列。 一些协程可以向此通道发送数据，另外一些协程可以从此通道接收数据。</p>
      
            <p>随着一个数据值的传递（发送和接收），一些数据值的所有权从一个协程转移到了另一个协程。 当一个协程发送一个值到一个通道，我们可以认为此协程释放了（通过此发送值可以访问到的）一些值的所有权。 当一个协程从一个通道接收到一个值，我们可以认为此协程获取了（通过此接受值可以访问到的）一些值的所有权。</p>
      
            <p>当然，在通过通道传递数据的时候，也可能没有任何所有权发生转移。</p>
      
            <p>所有权发生转移的值常常被传递的值所引用着，但有时候也并非如此。 在Go中，数据所有权的转移并非体现在语法上，而是体现在逻辑上。 Go通道可以帮助程序员轻松地避免数据竞争，但不会防止程序员因为犯错而写出错误的并发代码的情况发生。</p>
            
            <p>传统的数据同步技术提供在sync和sync/atomic标准库包中。</p>
      
            <h4>通道类型和值</h4>
            <p>通道可以是双向的，也可以是单向的。</p>
            <ul>
              <li>字面形式chan T表示一个元素类型为T的双向通道类型。 编译器允许从此类型的值中接收和向此类型的值中发送数据。</li>
              <li>字面形式chan<- T表示一个元素类型为T的单向发送通道类型。 编译器不允许从此类型的值中接收数据。</li>
              <li>字面形式<-chan T表示一个元素类型为T的单向接收通道类型。 编译器不允许向此类型的值中发送数据。</li>
            </ul>
            <p>双向通道chan T的值可以被隐式转换为单向通道类型chan<- T和<-chan T，但反之不行（即使显式也不行）。 类型chan<- T和<-chan T的值也不能相互转换。</p>

            <p>每个通道值有一个容量属性。 一个容量为0的通道值称为一个非缓冲通道（unbuffered channel），一个容量不为0的通道值称为一个缓冲通道（buffered channel）。</p>

            <p>通道类型的零值也使用预声明的<span class="text-black-300">nil</span>来表示。 一个非零通道值必须通过内置的make函数来创建。 比如make(chan int, 10)将创建一个元素类型为int的通道值。 第二个参数指定了欲创建的通道的容量。此第二个实参是可选的，它的默认值为0。</p>
          </article>
      </div>
    </div>
  </div>
</body>
</html>